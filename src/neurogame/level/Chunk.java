/**
 * @author Marcos Lemus
 **/
package neurogame.level;

import java.awt.geom.Path2D;
import java.util.ArrayList;
import java.util.List;

/**
 * Holds a list of paths, and the shapes generated by 
 * all the vertices in the chunk.
 */
public final class Chunk {

    private List<Path> pathList;
    private Path2D.Double[] topAndBottom;
    private double max;
    private double min;

    /**
     * Class constructor
     * takes the number of vertice pairs to generate in 
     * a chunk and the type of path
     * @param chunkSize
     * @param pathType 
     */
    public Chunk(int chunkSize, EnumPathType pathType){
        this();
        randomize(new Path(), chunkSize, pathType);
    }

    /**
     * Class constructor
     * takes a reference the chunk size and path type
     * @param reference
     * @param chunkSize
     * @param pathType 
     */
    public Chunk(Path reference, int chunkSize, EnumPathType pathType){
        this();
        pathList = new ArrayList<>();
        randomize(reference, chunkSize, pathType);
    }

    /**
     * Private constructor
     * used to initialize everything.
     */
    private Chunk(){
        pathList = new ArrayList<>();
        topAndBottom = new Path2D.Double[2];
        topAndBottom[0] = new Path2D.Double();
        topAndBottom[1] = new Path2D.Double();
    }

    /**
     * fills the list with vertices depending on the pathType 
     * resets pathList and Path2D objects and re fill them with newly generated
     * points.
     * @param reference
     * @param chunkSize
     * @param pathType 
     */
    public void randomize(Path reference, int chunkSize, EnumPathType pathType){
        pathList.clear();
        
        topAndBottom[0].reset();
        topAndBottom[1].reset();
        topAndBottom[0].moveTo(reference.getX(), 0);
        topAndBottom[1].moveTo(reference.getX(), 1);
        
        topAndBottom[0].lineTo(reference.getX(), reference.getTopY());
        topAndBottom[1].lineTo(reference.getX(), reference.getBottomY());

        Path p = new Path(reference, .5, pathType);
        
        for(int c = 0; c < chunkSize; c++){
            if(p.getTopY() < min){
                min = p.getTopY();
            }
            
            if(p.getBottomY() < max){
                max = p.getBottomY();
            }
            
            pathList.add(p);
            topAndBottom[0].lineTo(p.getX(), p.getTopY());
            topAndBottom[1].lineTo(p.getX(), p.getBottomY());

            p = new Path(p, .5, pathType);
        }

        topAndBottom[0].lineTo(chunkSize * pathType.getStepSize() + reference.getX(), 0);
        topAndBottom[1].lineTo(chunkSize * pathType.getStepSize() + reference.getX(), 1);

        topAndBottom[0].closePath();
        topAndBottom[1].closePath();
        
        System.out.println(pathList.get(pathList.size() - 1));
    }

    /////////////////////////////////////////////////////////////////
    // Getters
    /////////////////////////////////////////////////////////////////
    
    public List<Path> getPathList(){
        return pathList;
    }

    public Path2D.Double[] getTopAndBottom(){
        return topAndBottom;
    }

    public Path2D.Double getTop(){
        return topAndBottom[0];
    }

    public Path2D.Double getBottom(){
        return topAndBottom[1];
    }

    public Path getReference(){
        return pathList.get(pathList.size() - 1);
    }
    
    public double getMax(){
        return max;
    }
    
    public double getMin(){
        return min;
    }
}
