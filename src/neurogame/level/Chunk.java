/**
 * @author Marcos Lemus
 * */
package neurogame.level;

import java.awt.geom.Path2D;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import neurogame.library.Library;

/**
 * Holds a list of paths, and the shapes generated by
 * all the vertices in the chunk.
 */
public final class Chunk {

    private List<Path> pathList;
    private Path2D.Double[] topAndBottom;
    private EnumPathType pathType;
    private double max;
    private double min;
    private double center;

    private final Random random = Library.RANDOM;

    /**
     * Class constructor
     * takes the number of vertice pairs to generate in
     * a chunk and the type of path
     * @param chunkSize
     * @param pathType
     */
    public Chunk(int chunkSize, EnumPathType pathType){
        this();
        this.pathType = pathType;
        randomize(new Path(), chunkSize);
    }

    /**
     * Class constructor
     * takes a reference the chunk size and path type
     * @param reference
     * @param chunkSize
     * @param pathType
     */
    public Chunk(Path reference, int chunkSize, EnumPathType pathType){
        this();
        this.pathType = pathType;
        pathList = new ArrayList<>();
        randomize(reference, chunkSize);
    }

    /**
     * Private constructor
     * used to initialize everything.
     */
    private Chunk(){
        pathList = new ArrayList<>();
        topAndBottom = new Path2D.Double[2];
        topAndBottom[0] = new Path2D.Double();
        topAndBottom[1] = new Path2D.Double();
        center = random.nextDouble();
    }

    /**
     * resets pathList and Path2D objects and re fills them with newly generated
     * points.
     * @param reference
     * @param chunkSize
     */
    public void randomize(Path reference, int chunkSize){
        pathList.clear();

        topAndBottom[0].reset();
        topAndBottom[1].reset();
        topAndBottom[0].moveTo(reference.getX(), 0);
        topAndBottom[1].moveTo(reference.getX(), 1);

        topAndBottom[0].lineTo(reference.getX(), reference.getTopY());
        topAndBottom[1].lineTo(reference.getX(), reference.getBottomY());

        Path p = new Path(reference, center, pathType);

        if(pathType == EnumPathType.CURVED){
            curved(p, chunkSize);
        }
        else if(pathType == EnumPathType.SQUARE){
            square(p, chunkSize);
        }
        else{

            for(int c = 0; c < chunkSize; c++){
                if(p.getTopY() < min){
                    min = p.getTopY();
                }

                if(p.getBottomY() < max){
                    max = p.getBottomY();
                }

                pathList.add(p);
                topAndBottom[0].lineTo(p.getX(), p.getTopY());
                topAndBottom[1].lineTo(p.getX(), p.getBottomY());

                p = newPath(p, center);
            }
        }

        topAndBottom[0].lineTo(chunkSize * pathType.getStepSize() + reference.getX(), 0);
        topAndBottom[1].lineTo(chunkSize * pathType.getStepSize() + reference.getX(), 1);

        topAndBottom[0].closePath();
        topAndBottom[1].closePath();
    }

    /**
     * generate multiple vertices to create a square effect.
     * @param p
     * @param chunkSize
     */
    private void square(Path p, int chunkSize){
        Path p2;
        for(int c = 0; c < chunkSize; c++){
            p2 = new Path(p.getX() - pathType.getStepSize(),
                          p.getTopY(),
                          p.getBottomY(),
                          pathType);

            if(p.getTopY() < min){
                min = p.getTopY();
            }

            if(p.getBottomY() < max){
                max = p.getBottomY();
            }

            pathList.add(p2);
            pathList.add(p);

            topAndBottom[0].lineTo(p2.getX(), p2.getTopY());
            topAndBottom[1].lineTo(p2.getX(), p2.getBottomY());

            topAndBottom[0].lineTo(p.getX(), p.getTopY());
            topAndBottom[1].lineTo(p.getX(), p.getBottomY());

            p = newPath(p, center);
        }
    }

    /**
     * Generate the chunk using curved lines.
     * @param p
     * @param chunkSize
     */
    private void curved(Path p, int chunkSize){
        int r;
        double curve;
        double lastX;
        double lastTopY;
        double lastBottomY;

        pathList.add(p);

        for(int c = 1; c < chunkSize; c++){
            r = random.nextInt(2);
            curve = r == 1 ? random.nextDouble() * .1: random.nextDouble() * -.1;

            lastX = p.getX();
            lastTopY = p.getTopY();
            lastBottomY = p.getBottomY();

            p = newPath(p, center);

            if(p.getTopY() < min){
                min = p.getTopY();
            }

            if(p.getBottomY() < max){
                max = p.getBottomY();
            }

            pathList.add(p);
            topAndBottom[0].curveTo(lastX,
                                    lastTopY,
                                    (lastX + p.getX()) / 2,
                                    (p.getTopY() + lastTopY) / 2 + curve,
                                    p.getX(),
                                    p.getTopY());
            
            /** re randomize the curve to avoid identical sides. **/
            r = random.nextInt(2);
            curve = r == 1 ? random.nextDouble() * .1: random.nextDouble() * -.1;

            topAndBottom[1].curveTo(lastX,
                                    lastBottomY,
                                    (lastX + p.getX()) / 2,
                                    (p.getBottomY() + lastBottomY) / 2 + curve,
                                    p.getX(),
                                    p.getBottomY());

        }
    }

    /**
     * Creates a new Path given the arguments and 
     * checks if it is the new min or max.
     * @param p
     * @param center
     * @return new Path() 
     */
    private Path newPath(Path p, double center){
        if(p.isCentered()){
            center = random.nextDouble();
        }

        Path path = new Path(p, center, pathType);

        if(path.getTopY() < min){
            min = path.getTopY();
        }

        if(path.getBottomY() < max){
            max = path.getBottomY();
        }

        return path;
    }
    
    /**
     * sets the chunks next generated pathType.
     * @param pathType 
     */
    public void setPathType(EnumPathType pathType){
        this.pathType = pathType;
    }

    /////////////////////////////////////////////////////////////////
    // Getters
    /////////////////////////////////////////////////////////////////
    public List<Path> getPathList(){
        return pathList;
    }

    public Path2D.Double[] getTopAndBottom(){
        return topAndBottom;
    }

    public Path2D.Double getTop(){
        return topAndBottom[0];
    }

    public Path2D.Double getBottom(){
        return topAndBottom[1];
    }

    public Path getReference(){
        return pathList.get(pathList.size() - 1);
    }

    public double getMax(){
        return max;
    }

    public double getMin(){
        return min;
    }
}
